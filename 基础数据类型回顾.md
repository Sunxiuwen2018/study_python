# 基础数据类型回顾
## 一、概括 *七大类*
    1. 布尔 bool =>真假
    2. 数字 int
    3. 浮点型 float
    4. 空   None   ==> 空不是假，不能直接用于条件判断，需要加not/is才行，如 not None 或 is None
    5. 字符串 str
    6. 列表 list
    7. 元组 tuple  ==> 不可变的列表，序列化会和列表一样的效果，区别是反序列化回来不会变成元组，而是列表
    8. 字典 dict
    9. 集合 set

    **总结**
        1. 可迭代数据类型：str、list、tuple、dict、set
        2. 不可变数据类型：bool、int、float、str、tuple
        3、 可变数据类型：list、dict、set
        4、 可通过`+`号数据类型：int、float、str、list、tuple

        # 列表，字典，集合都有pop方法，del方法
        # pop 列表按索引，字典按对象，集合随机删
        # del 列表按索引，字典，集合按对象，只能删除整个集合
        # remove 列表按对象，集合按对象，没有都报错，字典没有该方法,
        # 列表批量增加extend，字典/集合update

### 布尔bool
    1. 非0,非空则为True，None不是False[通过is或==判断都是不正确的]，只有None,0,"",[],(),{},ser()等通过bool转化才为False
    2. is 判断的是内存地址，== 判断的是值
    3. 条件判断优先级顺序： not  or  and
    4. 对于or，左边非零取左边，and相反

### 整形int
    **基础**
        二进制： 0，1
        八进制： 0~7     三位一体
        十进制： 0~9
        十六进制： 0~F   四位一体

**进制转换**

    进制之间的转换要注意每个进制的基本数码范围！！！
    二进制转十进制   int('1110', 2)     # 后面的2就表示2进制
    八进制转十进制   int('12345670', 8)
    十六进制转十进制 int('9ABCDEF', 16)

    十进制转二进制   bin(100)
    十进制转成八进制  oct(8)
    十进制转十六进制  hex(10)
    二进制转十六进制  hex(int('111',2))

**方法**
    int.bit_length()   转化成二进制后的位数
    py2与py3除法区别
    py3:
        3 / 2  ==> 1.5   整除得float
    py2：
        3 / 2  ==> 1     整除得int，除非除数或被除数为float才得float
        3.0 /2 ==>1.5
    py2与py3 整除(//)，取模 结果相同

### 字符串
    **基础**
    **不可变，可切片取值，可迭代**
    分割拼接替换处理：
    str.strip("char")   默认清除左右的空格，空白字符，也可指定左右的某个字符清理
    str.replace(old,new,count)  替换字符，可指定次数
    str.split("char"，count)    以char进行分割，可指定次数，将字符串转换成列表
    "".join(str(i) for i in [11,22,33])  将可迭代的列表等转换成字符串，注意字符串拼接必须是str，int不行，需要先转才行

    格式化：
    "%s_%d_%.2f" %('china', 22, 2)  格式化
    "%(name)s_%(age)d" %({"name":'china', "age":30})   可用字典
    "{0}_{1}_{0}".format()
    "{user}_{pwd}".format(**{'name':'bei','age':30})
    f"{name}"

    字母的处理：
    str.caplize()   首字母大写，其它都小写
    str.swapcase()  大小写反转
    stt.title()     单词间空白或以下划线分割的字母首字母大写，其它字母都小写
    str.upper()     单词全部转成大写
    str.isupper()
    str.lower()
    str.islower()
    str.satrswith('char')   以什么开头
    str.endswith()
    str.isspace()     注意空字符串不是全部空白，需要中间加空格才行如：" "

    查找元素：
    str.index('char', start,end)   查找元素的索引，有多个，发回第一次找到的元素的索引，没有报错
    str.find('char', start,end)    查索引，没有返回-1


### 列表list
    **基础**
        可变，可切片,可迭代,list的pop，del增删靠索引，字典靠元素
    **增**
        list.append(object)  无返回值，添加到最后
        list.insert(index,object) 无返回值，按索引添加
        list.extend(iterable)  无返回值，添加可迭代数据类型到最后，不会去重，支持的数据类型有==>列表，元组,字符串,字典的key,集合
    **删**
        list.pop(index=None)  返回值为删除的元素，默认删除最后一个元素，也可以删除指定索引的元素
        list.remove(object)   无返回值，删除指定元素
        del list[index]       无返回值，删除指定索引的元素
        del list              无返回值，删除列表
        list.clear()          无返回值，清空列表，列表还在
    **改**
        list[index]=newdata       按索引改
        list[:index]=[newdata]    按切片改，改的是整个连续的内存块，左右的元素个数可以不一样且都必须是可迭代的，（一旦切片有步长，就必须元素个数一致才行）！！！
    **查**
        list[index:]    按索引或切片查
        list.index(object,start=None,end=None)   查询某个元素的索引，没有报错,或者指定范围内第一次出现改元素的索引，注意范围取值为[start,end)
        [(index,object) for i in enumerate(list,start=1)]  按循环查
    **other**
        list.count(obj)  某个元素出现的次数
        len(list)        列表的长度
        list.sort(revers=False)   改变了列表，直接改变列表中元素排序，默认升序，revers为True时降序
        list.revers()    改变了列表，直接将列表中元素顺序反转过来，不排序
        list.copy()      浅拷贝
        sorted(list)     可以完整拷贝，生成新的列表，里面也可以通过function来定义数据排序等
        object in list   成员判断

### 元组tuple
    **不可变，只读列表，可迭代，元素可以为任意数据类型**
    **方法**
        tu.index(obj, start,end)
        tu.count(obj)
        len(tu)
    **注意点**
        单个元素时，要在后面加逗号： tu =(11,)   不加逗号就不是元组了，而是int
        i = 1,    这个也是元组

### 字典dict
    dic = {}
    key 与 value 的映射关系
    key为可哈希的，即不可变数据类型，int，bool，float，str，tuple
    value可为任意类型，即list，dict，set
    **增：**
    dic[key] = value1
    dic1.update(dic2)   将dic2中的内容导入dic1，如果与dic1中key相同则覆盖更新
    dic.setdefault(key,value)  value默认为None，一旦创建就无法更改，value为可变数据类型【】，可向里面添加，共用一个内存空间
    dict.fromkeys([a,b],value)  ==> {a:value,b:value}, value如果是可变数据类型，那么同上面一样也可添加，静态方法
    **删：**
    dic.pop(key)   返回删除的值
    del dic[key]   无返回值
    del dic        从内存中删除dic
    dic.clear()    清空列表
    dic.popitem()  随机删除一个
    **改：**
    dic[newkey] = value
    dic.update(dic2)
    **查：**
    dic[key]      没有报错
    dic.get(key)  没有返回None
    dic.values()
    dic.keys()
    dic.items()

### 集合set
    **基础**
        `可变数据类型`，`无序`，可增，删，不能直接改，`不能切片`，`元素唯一`，且只能是`不可哈希`类型

    **增**
    set.add(obj)
    set.update(iterable)  打散元素添加到集合中
    **删**
    set.pop()  随机删除一个
    set.remove(obj)
    set.clear()
    del set
    **查**
    没有方法用，无序不能切片，只能循环匹配
    **共用**
    len(set)
    set.copy() 浅拷贝















```
python学习工具
公众号：菜鸟学python
书：a byte of python，简明python教程，父与子的变成之旅，笨办法学python
视频：网易云课堂
网站：廖雪峰的官方网站，菜鸟教程，
工具：sublime，pycharm，visual studio

后端工程师技能要求：
1、前端要求：熟悉html+css+js+jquery
2、三大框架：vue，bootstrap，react，angular

网络编程需要背诵：
1、tcp/udp套接字连接模型
2、lock，锁，同步控制，《买票》
3、队列，queue，同步控制《生产者消费者模型》
4、进程池之回调函数
5、多进程，多线程（线程池），协程解原生socket弊端
6、IO多路复用

ps：线程池回调函数是在子线程运行
    进程池回调函数是在主进程运行

http请求8种方法： get，post，head，delete，put，options，connect，trace

post与get的区别？
1、get提交的数据会放在url之后，以？分割，并以键值的形式进行拼接，多个键值以&拼接，post请求数据是放在请求体中，get没有请求体
2、get提交的数据长度有限制（不同浏览器对url的长度有限制），post对数据的长度没有限制
3、get通过request.querystring获取变量值，post通过request.form来获取
4、get提交数据不安全，全部以明码方式显示在url上，post没有

输入url后发生的事情？
1、浏览器向dns申请解析域名所对应的ip
2、获取ip后，浏览器根据ip及端口号，向服务器发起tcp三次握手，建立连接
3、浏览器向服务器发起http请求
4、服务器根据请求中的参数做出响应，并将对应的资源发送给浏览器
5、浏览器拿到数据对页面进行渲染，显示内容
6、释放tcp连接，四次挥手

请求格式：
请求行：请求方法 http协议  版本
请求头：键值模式
空行
请求体：get请求没有，还是key=value



django框架拾遗
1、如果app未注册，那么做数据迁移就会报错
  注册格式： 应用名.apps.驼峰格式应用名Confing


2、静态文件目录，不管多少个目录，统一别名还用static

3、input标签加上required则必填，取消前端校验，在form标签上加上novalid

4、orm建好表后，再增加字段，需清空数据，不然报错，或者设置默认值

5、print先调用__str__，再repr，repr是容器类数据类型使用
   __str__=__repr__ 则结果一样



前端：

1.overflow：handle   和clear:both 区别，都在什么情况下使用其清除浮动？

2.选项卡，排他思想不理解？for循环点击事件？

3、inline-block 两个行内块中间会有空白折叠现象，可将父盒子font-size= 0 解决
使用 display:inline-block; 能解决元素在一行的问题，但是会存在行内元素在一行显示的问题：

div 之间的空格问题，可由父盒子的 font-size:0; 解决
div 垂直方向上的对齐问题，可由 vertical-align: base; 解决


/*设置绝对定位之后，margin:0 auto;不起任何作用，如果想让绝对定位的盒子居中。
当做公式记下来 设置子元素绝对定位，然后left:50%;
margin-left等于元素宽度的一半，实现绝对定位盒子居中*/


4、什么时候用css，什么时候用attr


list.remove()
set.remove()


python模块：
    日志模块：
        一、两种模式
            1.1、模块级默认配置函数（一般模式）
            特点：
                a、手动设置位置，手动设置信息
                b、无法同时标准输出到控制台和记录文件
                c、可以总体设置格式，无法单独某个，无法分割信息到不同文件及个性化格式设置
            1.2、流程
                1、导入模块  import logging
                2、选好程序位置，设置格式（可以配置多个参数）
                logging.basicConfig(
                                level=logging.DEBUG,
                                format ='%(asctime)s-%(filename)s-%(messages)s',
                                filename = 'my_log.log')
                3、设置日志记录信息
                    logging.DEBUG('debug:message')
                    logging.INFO('info:message')
                    logging.WARNING('waring:message')
                    logging.ERROR('error:message')
                    logging.critical('critical:message')
                注：message是字符串所以可以格式化%传变量
            2.1、自定义版，通过logging四大组件配置
            特点：
                1、可同时屏幕，文件写入
                2、可设全局日志级别，日记文件写入级别，屏幕打印级别及三个对象得不同显示格式
                3、可将日志信息分割程多个文件记录
            2.2、流程：
                1、导入模块 importlogging
                2、选好需记录日志位置（日志可封装成函数）
                3、通过日志器logger实例化一个对象log_obj = logging.getLogger()
                4、设置日志器处理日志消息的最低级别（全局）可以不改，默认debug
                    log_obj.setLevel(logging.DEBUG)
                5、创建句柄/屏幕句柄/等其它需分割日志句柄
                    file_handler2 = loging.FileHandler('errer.log')
                6、设置日志显示格式化（可为每个handler设，也可共用）
                7、设置各个handler的日志格式化模式
                8、设置各个handler的日志级别，必须高于日志器
                9、对象即日志器与句柄即处理器县官取
                10、设置各日志级别message
    随机数模块：random模块
        random.random()  0~1 之间的随机小数
        random.uniform(x,y) x~y之间的整数小数，无限循环
        random.randint(x,y)  [x,y] x~y之间的整数
        random.randrange(x,y,z) [x,y) 步长为z，整数
        random.chioce(callable)  随机取出一个元素
        random.sample(list,sep)  取出指定sep个元素
        random.suffle(list)  随机打乱
    模块搜索路劲：
        python启动加载模块，sys
        第一次导入时，会检查是否已经导入，已导入不再加载，直接引用，没有先找内建，后path找sys.path
    sys模块：
        sys.platform  打印平台名称
        sys.version  python解释器名称
        sys.path     当前python程序初始化环境变量
        临时更改
        sys.path.append(path)
        sya.path.insert(0,path)  插入
    os与sys的区别，什么时候用
    时间模块time



python异常处理：
    错误分类：
        1、语法错误：你程序未执行之前，python已提示
        2、逻辑错误
    异常：
        由错误造成的信号，且出现终止程序
        valueError   IndexError ……
        由错误引发的，而且出现异常就会终止异常
        异常就会终止程序，用户体验差
        让代码不冗余
        try .... except
        try .... except ....else... 不发生异常则else
        try ....except....fanally


网络编程，并发编程：
    同步控制：锁、信号量、池、事件
    join  同步控制，获得结果
    锁     数据安全
    池     解决并发

python版本控制：virtualenv   pipenv

iO多路复用：
io多路复用是操作系统提供的一种监听网络Io操作的机制
监听三个列表，分别为读，写，条件事件对象
当某一个列表有的对应的事件发生的时候，操作胸痛通知(select通知)应用程序
操作胸痛根据返回的内容做具体操作




py2与py3区别：
89年创立，08年出2.7和3.0

1、打印，py2 print可以不用括号，也可以用括号，py3必须用括号
2、除法，py2 / 除法得 int， py3得float
3、编码，py2 默认ascii，py3 默认utf-8
4、range，py2 有range和xrange，py3只有range可迭代
5、输出，py2 为raw_input()返回为str，input如果输入是int，返回值类型也为int,py3为input（）返回得数据类型始终为str

--  node -v  查看Node.js 版本信息

　　--  npm -v  查看npm版本信息

更新npm到指定版本：

　　--  npm install npm@5.3.0 -g

　　-- npm install npm@latest -g 更新最新的稳定版本
```